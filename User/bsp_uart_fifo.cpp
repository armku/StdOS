#include "stm32f10x.h"
#include "bsp_uart_fifo.h"
#include <stdio.h>

#define ENABLE_INT()	__set_PRIMASK(0)	/* 使能全局中断 */
#define DISABLE_INT()	__set_PRIMASK(1)	/* 禁止全局中断 */

#define UART1_TX_BUF_SIZE	1*1024
#define UART1_RX_BUF_SIZE	1*1024

UART_T g_tUart1;
uint8_t g_TxBuf1[UART1_TX_BUF_SIZE]; /* 发送缓冲区 */
uint8_t g_RxBuf1[UART1_RX_BUF_SIZE]; /* 接收缓冲区 */

void InitHardUart(void);
void UartSend(UART_T *_pUart, uint8_t *_ucaBuf, int _usLen);
uint8_t UartGetChar(UART_T *_pUart, uint8_t *_pByte);
void UartIRQ(UART_T *_pUart);
void ConfigUartNVIC(void);

void FIFO::SetBuf(uint8_t *buf, int len)
{
    if (len >= 0)
    {
        this->pBuf = buf;
        this->BufSize = len;
    }
    this->Clear();
}

void FIFO::Clear()
{
    this->Write = 0;
    this->Read = 0;
    this->Count = 0;
}

int FIFO::Push(uint8_t da)
{
    this->pBuf[this->Write] = da;
    if (++this->Write >= this->BufSize)
    {
        this->Write = 0;
    }
    //if (this->Count < this->BufSize)
    {
        this->Count++;
        return 0;
    }
    //else
    {
        return  - 1;
    }
}

int FIFO::Pop(uint8_t *da)
{
    *da = this->pBuf[this->Read];
    if (++this->Read >= this->BufSize)
    {
        this->Read = 0;
    }
    if (this->Count)
    {
        this->Count--;
        return 0;
    }
    else
    {
        return  - 1;
    }
}

bool FIFO::BufIsEmpty()
{
    return this->Count == 0;
}

bool FIFO::BufIsFull()
{
    return this->Count >= this->BufSize;
}

/*
 *********************************************************************************************************
 *	函 数 名: bsp_InitUart
 *	功能说明: 初始化串口硬件，并对全局变量赋初值.
 *	形    参:  无
 *	返 回 值: 无
 *********************************************************************************************************
 */
void bsp_InitUart(void)
{
    g_tUart1.uart = USART1; /* STM32 串口设备 */
    g_tUart1.tx.SetBuf(g_TxBuf1, UART1_TX_BUF_SIZE);
    g_tUart1.rx.SetBuf(g_RxBuf1, UART1_RX_BUF_SIZE);
    g_tUart1.tx.Clear();
    g_tUart1.rx.Clear();
    g_tUart1.ReciveNew = 0; /* 接收到新数据后的回调函数 */

    InitHardUart(); /* 配置串口的硬件参数(波特率等) */

    ConfigUartNVIC(); /* 配置串口中断 */
}

/*
 *********************************************************************************************************
 *	函 数 名: ComToUart
 *	功能说明: 将COM端口号转换为UART指针
 *	形    参: _ucPort: 端口号(COM1 - COM6)
 *	返 回 值: uart指针
 *********************************************************************************************************
 */
UART_T *ComToUart(COM _ucPort)
{
    if (_ucPort == COM1)
    {
        return  &g_tUart1;
    }
    else
    {
        /* 不做任何处理 */
        return 0;
    }
}

/*
 *********************************************************************************************************
 *	函 数 名: comSendBuf
 *	功能说明: 向串口发送一组数据。数据放到发送缓冲区后立即返回，由中断服务程序在后台完成发送
 *	形    参: _ucPort: 端口号(COM1 - COM6)
 *			  _ucaBuf: 待发送的数据缓冲区
 *			  _usLen : 数据长度
 *	返 回 值: 无
 *********************************************************************************************************
 */
void comSendBuf(COM _ucPort, uint8_t *_ucaBuf, int _usLen)
{
    UART_T *pUart;

    pUart = ComToUart(_ucPort);
    if (pUart == 0)
    {
        return ;
    }
    UartSend(pUart, _ucaBuf, _usLen);
}

/*
 *********************************************************************************************************
 *	函 数 名: comSendChar
 *	功能说明: 向串口发送1个字节。数据放到发送缓冲区后立即返回，由中断服务程序在后台完成发送
 *	形    参: _ucPort: 端口号(COM1 - COM6)
 *			  _ucByte: 待发送的数据
 *	返 回 值: 无
 *********************************************************************************************************
 */
void comSendChar(COM _ucPort, uint8_t _ucByte)
{
    comSendBuf(_ucPort, &_ucByte, 1);
}

/*
 *********************************************************************************************************
 *	函 数 名: comGetChar
 *	功能说明: 从串口缓冲区读取1字节，非阻塞。无论有无数据均立即返回
 *	形    参: _ucPort: 端口号(COM1 - COM6)
 *			  _pByte: 接收到的数据存放在这个地址
 *	返 回 值: 0 表示无数据, 1 表示读取到有效字节
 *********************************************************************************************************
 */
uint8_t comGetChar(COM _ucPort, uint8_t *_pByte)
{
    UART_T *pUart;

    pUart = ComToUart(_ucPort);
    if (pUart == 0)
    {
        return 0;
    }

    return UartGetChar(pUart, _pByte);
}

/*
 *********************************************************************************************************
 *	函 数 名: InitHardUart
 *	功能说明: 配置串口的硬件参数（波特率，数据位，停止位，起始位，校验位，中断使能）适合于STM32-F4开发板
 *	形    参: 无
 *	返 回 值: 无
 *********************************************************************************************************
 */
void InitHardUart(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;

    /* 第1步：打开GPIO和USART部件的时钟 */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);

    /* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    /* 第3步：将USART Rx的GPIO配置为浮空输入模式
    由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
    但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
     */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    /* 第4步： 配置串口硬件参数 */
    USART_InitStructure.USART_BaudRate = 256000; /* 波特率 */
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    USART_Init(USART1, &USART_InitStructure);

    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); /* 使能接收中断 */
    /*
    USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
    注意: 不要在此处打开发送中断
    发送中断使能在SendUart()函数打开
     */
    USART_Cmd(USART1, ENABLE); /* 使能串口 */

    /* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
    如下语句解决第1个字节无法正确发送出去的问题 */
    USART_ClearFlag(USART1, USART_FLAG_TC); /* 清发送完成标志，Transmission Complete flag */
}

/*
 *********************************************************************************************************
 *	函 数 名: ConfigUartNVIC
 *	功能说明: 配置串口硬件中断.
 *	形    参:  无
 *	返 回 值: 无
 *********************************************************************************************************
 */
void ConfigUartNVIC(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    /* 使能串口1中断 */
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);

}

/*
 *********************************************************************************************************
 *	函 数 名: UartSend
 *	功能说明: 填写数据到UART发送缓冲区,并启动发送中断。中断处理函数发送完毕后，自动关闭发送中断
 *	形    参:  无
 *	返 回 值: 无
 *********************************************************************************************************
 */
void UartSend(UART_T *_pUart, uint8_t *_ucaBuf, int _usLen)
{
    uint16_t i;

    for (i = 0; i < _usLen; i++)
    {
        /* 如果发送缓冲区已经满了，则等待缓冲区空 */
        #if 0
        #else 
            /* 当 _pUart->usTxBufSize == 1 时, 下面的函数会死掉(待完善) */
            while (_pUart->tx.BufIsFull())
                ;
        #endif 

        /* 将新数据填入发送缓冲区 */
        _pUart->tx.Push(_ucaBuf[i]);
    }
    USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);
}

/*
 *********************************************************************************************************
 *	函 数 名: UartGetChar
 *	功能说明: 从串口接收缓冲区读取1字节数据 （用于主程序调用）
 *	形    参: _pUart : 串口设备
 *			  _pByte : 存放读取数据的指针
 *	返 回 值: 0 表示无数据  1表示读取到数据
 *********************************************************************************************************
 */
uint8_t UartGetChar(UART_T *_pUart, uint8_t *_pByte)
{
    #if 1
        uint16_t usCount;

        /* usRxWrite 变量在中断函数中被改写，主程序读取该变量时，必须进行临界区保护 */
        DISABLE_INT();
        usCount = _pUart->rx.Count;
        ENABLE_INT();

        /* 如果读和写索引相同，则返回0 */
        //if (_pUart->usRxRead == usRxWrite)
        if (usCount == 0)
        /* 已经没有数据 */
        {
            return 0;
        }
        else
        {
            #if 1
                *_pByte = _pUart->rx.pBuf[_pUart->rx.Read]; /* 从串口接收FIFO取1个数据 */

                /* 改写FIFO读索引 */
                DISABLE_INT();
                if (++_pUart->rx.Read >= _pUart->rx.BufSize)
                {
                    _pUart->rx.Read = 0;
                }
                _pUart->rx.Count--;
                ENABLE_INT();
            #else 
                _pUart->rx.Pop(_pByte);
            #endif 
            return 1;
        }
    #else 
        if (_pUart->rx.BufIsEmpty())
            return 0;
        _pUart->rx.Pop(_pByte);
        return 1;
    #endif 
}

/*
 *********************************************************************************************************
 *	函 数 名: UartIRQ
 *	功能说明: 供中断服务程序调用，通用串口中断处理函数
 *	形    参: _pUart : 串口设备
 *	返 回 值: 无
 *********************************************************************************************************
 */
void UartIRQ(UART_T *_pUart)
{
    /* 处理接收中断  */
    if (USART_GetITStatus(_pUart->uart, USART_IT_RXNE) != RESET)
    {
        /* 从串口接收数据寄存器读取数据存放到接收FIFO */
        uint8_t ch;

        ch = USART_ReceiveData(_pUart->uart);
        _pUart->rx.Push(ch);

        /* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
        //if (_pUart->usRxWrite == _pUart->usRxRead)
        //if (_pUart->usRxCount == 1)
        {
            if (_pUart->ReciveNew)
            {
                _pUart->ReciveNew(ch);
            }
        }
    }

    /* 处理发送缓冲区空中断 */
    if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
    {
        //if (_pUart->usTxRead == _pUart->usTxWrite)
        if (_pUart->tx.BufIsEmpty())
        {
            /* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
            USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);

            /* 使能数据发送完毕中断 */
            USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
        }
        else
        {
            /* 从发送FIFO取1个字节写入串口发送数据寄存器 */
            uint8_t ch;
            if (_pUart->tx.Pop(&ch) == 0)
                USART_SendData(_pUart->uart, ch);
        }

    }
    /* 数据bit位全部发送完毕的中断 */
    else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
    {
        //if (_pUart->usTxRead == _pUart->usTxWrite)
        if (_pUart->tx.BufIsEmpty())
        {
            /* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
            USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
        }
        else
        {
            /* 正常情况下，不会进入此分支 */
            uint8_t ch;
            if (_pUart->tx.Pop(&ch) == 0)
                USART_SendData(_pUart->uart, ch);
        }
    }
}

/*
 *********************************************************************************************************
 *	函 数 名: USART1_IRQHandler  USART2_IRQHandler USART3_IRQHandler UART4_IRQHandler UART5_IRQHandler
 *	功能说明: USART中断服务程序
 *	形    参: 无
 *	返 回 值: 无
 *********************************************************************************************************
 */
void USART1_IRQHandlerCOM1(void)
{
    UartIRQ(&g_tUart1);
}

#ifdef __cplusplus
    extern "C"
    {
    #endif 
    /*
     *********************************************************************************************************
     *	函 数 名: fputc
     *	功能说明: 重定义putc函数，这样可以使用printf函数从串口1打印输出
     *	形    参: 无
     *	返 回 值: 无
     *********************************************************************************************************
     */
    int fputc(int ch, FILE *f)
    {
        #if 0	/* 将需要printf的字符通过串口中断FIFO发送出去，printf函数会立即返回 */
            comSendChar(COM1, ch);
            return ch;
        #else /* 采用阻塞方式发送每个字符,等待数据发送完毕 */
            /* 写一个字节到USART1 */
            USART_SendData(USART1, (uint8_t)ch);

            /* 等待发送结束 */
            while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET){}

            return ch;
        #endif 
    }

    /*
     *********************************************************************************************************
     *	函 数 名: fgetc
     *	功能说明: 重定义getc函数，这样可以使用getchar函数从串口1输入数据
     *	形    参: 无
     *	返 回 值: 无
     *********************************************************************************************************
     */
    int fgetc(FILE *f)
    {

        #if 1	/* 从串口接收FIFO中取1个数据, 只有取到数据才返回 */
            uint8_t ucData;

            while (comGetChar(COM1, &ucData) == 0)
                ;

            return ucData;
        #else 
            /* 等待串口1输入数据 */
            while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET)
                ;

            return (int)USART_ReceiveData(USART1);
        #endif 
    }
    #ifdef __cplusplus
    }
#endif 

#ifdef DEBUG
    /* 定义例程名和例程发布日期 */
    #define EXAMPLE_NAME	"V4-003_串口和PC机通信（串口中断、FIFO机制）"
    #define EXAMPLE_DATE	"2015-08-30"
    #define DEMO_VER		"1.0"
    void PrintfLogo()
    {
        printf("*************************************************************\n\r");
        printf("* 例程名称   : %s\r\n", EXAMPLE_NAME); /* 打印例程名称 */
        printf("* 例程版本   : %s\r\n", DEMO_VER); /* 打印例程版本 */
        printf("* 发布日期   : %s\r\n", EXAMPLE_DATE); /* 打印例程日期 */

        /* 打印ST固件库版本，宏定义在 stm32f4xx.h 文件 */
        printf("* 固件库版本 : %d.%d.%d\r\n", __STM32F10X_STDPERIPH_VERSION_MAIN, __STM32F10X_STDPERIPH_VERSION_SUB1, __STM32F10X_STDPERIPH_VERSION_SUB2);

        /* 打印 CMSIS 版本. 宏定义在 core_cm4.h 文件 */
        printf("* CMSIS版本  : %X.%02X\r\n", __CM3_CMSIS_VERSION_MAIN, __CM3_CMSIS_VERSION_SUB);

        printf("* \n\r"); /* 打印一行空格 */
        printf("* QQ    : 1295744630 \r\n");
        printf("* Email : armfly@qq.com \r\n");
        printf("* Copyright www.armfly.com 安富莱电子\r\n");
        printf("*************************************************************\n\r");
    }
    void fiforoutin(void *param)
    {
        uint8_t read;
        if (comGetChar(COM1, &read))
        {
            switch (read)
            {
                case '1':
                    printf("接收：1\n\r");
                    break;
                case '2':
                    printf("接收：2\n\r");
                    break;
                case '3':
                    printf("接收：3\n\r");
                    break;
                case '4':
                    printf("接收：4\n\r");
                    break;
            }
        }
    }
    void FifoTest()
    {
        NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
        bsp_InitUart(); /* 初始化串口驱动 */
        PrintfLogo();
        Sys.AddTask(fiforoutin, 0, 0, 200, "fiforoutin");
    }
#endif
